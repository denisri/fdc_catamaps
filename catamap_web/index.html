<!DOCTYPE html>
<html>
    <head>
        <meta charset=utf-8>
        <title id="main_title">GRS 14 2023</title>
        <style>
            body {
                margin: 0;
                background: #000;
                text-align: center;
                color: #fff;
                overflow-y: hidden;
                touch-action: none;
/*                 font-size: 20px; */
            }
            canvas {
              width: 100%;
              height: 100%;
              z-index: 2;
              top: 300px;
            }
            .right_col {
                align-content: right;
                align-items: right;
                position: absolute;
                font-size: 18px;
            }
            .button_bar {
                width: 100%;
                align-content: right;
                position: absolute;
                top: 0%;
                right: 1%;
                background: #60606080;
                font-size: 18px;
                display: block;
            }
            fieldset {
                border: 1px solid #888;
                align-content: left;
                text-align: left;
                width: 25%;
/*                 display: inline-block; */
                float: right;
                right: 0%;
                z-index: 10;
            }
            .mesh_button {
                background: #50505080;
                border: 1px;
                border-color: #80808080;
                color: #d0d0d0;
                width: 100%;
                z-index: 10;
            }
            .mesh_button:hover {
                background-color: #707070c0;
            }
            .mesh_checkbox {
                background: #50505080;
                border: 1px;
                border-color: #80808080;
                color: #d0d0d0;
                z-index: 10;
            }
            .top_row {
                position: absolute;
                top: 0%;
                left: 0%;
                width: 100%;
                text-align: center;
                color: #a0a0a0;
                z-index: 10;
            }
            .bottom_row {
                position: absolute;
/*                 top: 90%; */
                bottom: 0%;
                width: 100%;
                text-align: center;
                color: #a0a0a0;
                z-index: 0;
            }
            .help {
                display: none;
                z-index: 3;
                position: absolute;
                top: 20%;
                left: 20%;
            }
            .control_help {
                text-align: left;
            }
            .player {
                display: none;
                z-index: 30;
                position: absolute;
                top: 2%;
                left: 2%;
                width: 30%;
                height: 40%;
                background: #60606080;
            }
            .media_frame {
                width: 100%;
                height: 100%;
                display: block;
                z-index: 10;
            }
            .photo_frame {
                margin: 0px auto 0px;
                width: 100%;
                height: 100%;
                display: block;
            }
            .media_button {
                background: #80808080;
                border: 1px;
                border-color: #80808080;
                color: #d0d0d0;
                width: 30px;
                z-index: 10;
                font-size: 18px;
            }
            .media_button:hover {
                background-color: #a0a0a0d0;
            }
            .media_button2 {
                background: #50505080;
                border: 1px;
                border-color: #80808080;
                color: #d0d0d0;
                width: 40%;
                z-index: 10;
                font-size: 18px;
            }
            #debug_win {
                position: absolute;
                top: 20%;
                left: 20%;
                display: block;
            }
        </style>
        <link rel="stylesheet" type="text/css" href="catamap.css" />
        <link rel="manifest" href="catamap_webmanifest.json" />
    </head>

    <body>

      <div class="top_row">
        <h1 id="title_0">GRAND RÃ‰SEAU SUD</h1>
        <h3 id="title_1">LE FOND DU CREW 2023</h3>
        <h3 id="title_2"></h3>
      </div>

      <div class="button_bar" id="button_bar">
        <fieldset id="mesh_fields" class="right_col">
          <legend>Charger/voir:</legend>
          <div id="mesh_buttons">
            <button id="all" class="mesh_button">Tous</button><br/>
            <br id="categories_sep" />
            <input type="checkbox" id="map_mode" class="mesh_checkbox">
              <label for="map_mode">Mode 2D</label></input><br/>
            <input type="checkbox" id="private_mode" class="mesh_checkbox">
              <label for="private_mode">Private</label></input><br/>
            <div id="private_code_block"><label for="private_code">Code: </label><input type="text" id="private_code" size="8"></input></div>
            <br/>
            <button id="help" class="mesh_button">Aide</button>
          </div>
        </fieldset>
        <button id="show_buttons" class="media_button" style="position: absolute; top: 10px; right: 1%; z-index: 20">&#x25BC;</button>
      </div>

      <div style="border: 0px; bottom: 0%; left: 0%; width: 100%; height: auto; display: block; position: absolute; margin: auto;">
        <audio controls id="audio_player" style="display: none; margin-left: auto; margin-right: auto; bottom: 2%; z-index: 20;"/>
      </div>

      <script>
      // Registering Service Worker
      if ('serviceWorker' in navigator)
      {
        console.log('registrer service');
        const my_path =  window.location.pathname;
        const s = my_path.split('/');
        const my_dir = my_path.substring(0, my_path.length - s[s.length - 1].length);
        console.log('service:', my_dir + 'sw.js');
        navigator.serviceWorker.register(my_dir + 'sw.js');
      }
      else
      {
        console.log('serviceWorker not available in browser.');
      }
      </script>

        <script type="importmap">
          {
            "imports": {
              "three": "../three/build/three.module.js",
              "three/addons/": "../three/examples/jsm/",
              "../utils/": "../three/examples/jsm/utils/"
            }
          }
        </script>
        <script type="module" src="jquery.js"></script>

        <script type="module">

    import * as THREE from 'three'
    import { OBJLoader } from 'three/addons/loaders/OBJLoader.js'
    import { MTLLoader } from 'three/addons/loaders/MTLLoader.js'
    import { OrbitControls } from './OrbitControls2.js'
//           import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js'
    import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js'
    console.log('IMPORTED.')

    function sha1 (str) {
      //  discuss at: https://locutus.io/php/sha1/
      // original by: Webtoolkit.info (https://www.webtoolkit.info/)
      // improved by: Michael White (https://getsprink.com)
      // improved by: Kevin van Zonneveld (https://kvz.io)
      //    input by: Brett Zamir (https://brett-zamir.me)
      //      note 1: Keep in mind that in accordance with PHP, the whole string is buffered and then
      //      note 1: hashed. If available, we'd recommend using Node's native crypto modules directly
      //      note 1: in a steaming fashion for faster and more efficient hashing
      //   example 1: sha1('Kevin van Zonneveld')
      //   returns 1: '54916d2e62f65b3afa6e192e6a601cdbe5cb5897'
      let hash
      try {
        const crypto = require('crypto')
        const sha1sum = crypto.createHash('sha1')
        sha1sum.update(str)
        hash = sha1sum.digest('hex')
      } catch (e) {
        hash = undefined
      }
      if (hash !== undefined) {
        return hash
      }
      const _rotLeft = function (n, s) {
        const t4 = (n << s) | (n >>> (32 - s))
        return t4
      }
      const _cvtHex = function (val) {
        let str = ''
        let i
        let v
        for (i = 7; i >= 0; i--) {
          v = (val >>> (i * 4)) & 0x0f
          str += v.toString(16)
        }
        return str
      }
      let blockstart
      let i, j
      const W = new Array(80)
      let H0 = 0x67452301
      let H1 = 0xEFCDAB89
      let H2 = 0x98BADCFE
      let H3 = 0x10325476
      let H4 = 0xC3D2E1F0
      let A, B, C, D, E
      let temp
      // utf8_encode
      str = unescape(encodeURIComponent(str))
      const strLen = str.length
      const wordArray = []
      for (i = 0; i < strLen - 3; i += 4) {
        j = str.charCodeAt(i) << 24 |
          str.charCodeAt(i + 1) << 16 |
          str.charCodeAt(i + 2) << 8 |
          str.charCodeAt(i + 3)
        wordArray.push(j)
      }
      switch (strLen % 4) {
        case 0:
          i = 0x080000000
          break
        case 1:
          i = str.charCodeAt(strLen - 1) << 24 | 0x0800000
          break
        case 2:
          i = str.charCodeAt(strLen - 2) << 24 | str.charCodeAt(strLen - 1) << 16 | 0x08000
          break
        case 3:
          i = str.charCodeAt(strLen - 3) << 24 |
            str.charCodeAt(strLen - 2) << 16 |
            str.charCodeAt(strLen - 1) <<
          8 | 0x80
          break
      }
      wordArray.push(i)
      while ((wordArray.length % 16) !== 14) {
        wordArray.push(0)
      }
      wordArray.push(strLen >>> 29)
      wordArray.push((strLen << 3) & 0x0ffffffff)
      for (blockstart = 0; blockstart < wordArray.length; blockstart += 16) {
        for (i = 0; i < 16; i++) {
          W[i] = wordArray[blockstart + i]
        }
        for (i = 16; i <= 79; i++) {
          W[i] = _rotLeft(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1)
        }
        A = H0
        B = H1
        C = H2
        D = H3
        E = H4
        for (i = 0; i <= 19; i++) {
          temp = (_rotLeft(A, 5) + ((B & C) | (~B & D)) + E + W[i] + 0x5A827999) & 0x0ffffffff
          E = D
          D = C
          C = _rotLeft(B, 30)
          B = A
          A = temp
        }
        for (i = 20; i <= 39; i++) {
          temp = (_rotLeft(A, 5) + (B ^ C ^ D) + E + W[i] + 0x6ED9EBA1) & 0x0ffffffff
          E = D
          D = C
          C = _rotLeft(B, 30)
          B = A
          A = temp
        }
        for (i = 40; i <= 59; i++) {
          temp = (_rotLeft(A, 5) + ((B & C) | (B & D) | (C & D)) + E + W[i] + 0x8F1BBCDC) & 0x0ffffffff
          E = D
          D = C
          C = _rotLeft(B, 30)
          B = A
          A = temp
        }
        for (i = 60; i <= 79; i++) {
          temp = (_rotLeft(A, 5) + (B ^ C ^ D) + E + W[i] + 0xCA62C1D6) & 0x0ffffffff
          E = D
          D = C
          C = _rotLeft(B, 30)
          B = A
          A = temp
        }
        H0 = (H0 + A) & 0x0ffffffff
        H1 = (H1 + B) & 0x0ffffffff
        H2 = (H2 + C) & 0x0ffffffff
        H3 = (H3 + D) & 0x0ffffffff
        H4 = (H4 + E) & 0x0ffffffff
      }
      temp = _cvtHex(H0) + _cvtHex(H1) + _cvtHex(H2) + _cvtHex(H3) + _cvtHex(H4)
      return temp.toLowerCase()
    }



    function all_clicked(event=null)
    {
        // console.debug('ALL clicked.');
        if( event != null )
            event.stopPropagation();

        var i = 0;

        for( i=0; i!=categories.length; i++ )
            document.getElementById( categories[i] ).checked = true;
        for( i=0; i!=categories.length; i++ )
            category_clicked.bind( document.getElementById( categories[i] ) )( i, event );
   }

    function category_clicked(category, event=null)
    {
        if( event != null && event != undefined )
            event.stopPropagation();

        var display = this.checked;
        if( display == undefined )
            display = event.checked;
        console.debug(categories[category], display);
        if( display )
            load_meshes( category );
        else
            unload_meshes( category );
    }

    function redraw_objects()
    {
        var i = 0;

        for( i=0; i!=categories.length; i++ )
        {
            const display = document.getElementById( categories[i] ).checked;
            unload_meshes( i );
            if( display )
                load_meshes( i );
        }
    }

    function map_mode_clicked(event)
    {
        if( event != null )
            event.stopPropagation();

        var display = this.checked;
        if( display == undefined )
            display = event.checked;
        console.debug('map_mode clicked.', display);
        controls.mode_2d = display;
        if( display )
            set_map_2d_mode();
    }

    function private_mode_clicked(event)
    {
        if( event != null )
            event.stopPropagation();

        allow_private = this.checked;
        if( allow_private == undefined )
            allow_private = event.checked;
        console.log('private_mode clicked.', allow_private);

        if( allow_private )
        {
          document.getElementById( 'private_code_block' ).style.display = 'inline';
          var code = document.getElementById( 'private_code' ).value;
          console.log('code:', code);
          allow_private = check_private_code( code );
        }
        else
        {
          document.getElementById( 'private_code_block' ).style.display = 'none';
        }

        reset_object_lists( allow_private );
        redraw_objects();
    }

    function private_code_clicked(event)
    {
        if( event != null )
            event.stopPropagation();
        console.log('private_code clicked.');
        document.getElementById( 'private_code' ).focus();
    }

    function private_code_changed(event)
    {
        if( event != null )
            event.stopPropagation();
        const old_allow = allow_private;
        if( document.getElementById( 'private_mode' ).checked )
        {
          allow_private = check_private_code( this.value );
        }
        else
          allow_private = false;
        if( allow_private != old_allow )
        {
          reset_object_lists( allow_private );
          redraw_objects();
        }
    }

    function check_private_code( code )
    {
      return ( sha1(code) == private_code );
    }

    function set_font_sizes()
    {
        if(window.innerWidth < window.innerHeight )
        {
            document.getElementById( 'mesh_fields' ).style['font-size']
                = '4.0vw';
            document.getElementById( 'all' ).style['font-size']
                = '4.0vw';
            document.getElementById( 'help' ).style['font-size']
                = '4.0vw';
        }
        else if( window.innerWidth > 700 )
        {
//             var font_size = Math.round( window.innerWidth * 0.01 );
            document.getElementById( 'mesh_fields' ).style['font-size']
                = '2.0vw';
//                 = font_size + 'px';
            document.getElementById( 'all' ).style['font-size']
                = '2.0vw';
//                 = font_size + 'px';
            document.getElementById( 'help' ).style['font-size']
                = '2.0vw';
//                 = font_size + 'px';
        }
    }

    function query_string( url )
    {
      var q_url = url.split('?');
      if( q_url.length < 2 )
        return {};
      q_url = q_url[1];
      var qArr = q_url.split('&')
          ,qObj = {}
          ,i =-1;
      while(++i<qArr.length) {
          var qfrag = qArr[i].split('=');
          qObj[qfrag[0]] = qfrag[1];
      }
      return qObj;
    }


    var query = query_string( document.URL );

    set_font_sizes();

    var mouse;
    var rayCaster;
    var current_sound;

    document.getElementById( 'all' ).addEventListener( 'click', all_clicked );
    document.getElementById( 'map_mode' ).addEventListener( 'click', map_mode_clicked );
    document.getElementById( 'private_mode' ).addEventListener( 'click', private_mode_clicked );
    document.getElementById( 'private_code' ).addEventListener( 'click', private_code_clicked );
    document.getElementById( 'private_code' ).addEventListener( 'change', private_code_changed );

    // from https://stackoverflow.com/questions/5026961/html5-canvas-ctx-filltext-wont-do-line-breaks/21574562#21574562
    function fillTextMultiLine(ctx, text, x, y, hratio, centered) {
      var lines = text.split("\n");
      var m = ctx.measureText(lines[0]);
      var lineHeight = m.actualBoundingBoxAscent * hratio;
      var xd = 0;
      var lw = new Array(lines.length);
      y += m.actualBoundingBoxAscent;

      if( centered )
      {
        for (var i = 0; i < lines.length; ++i) {
          m = ctx.measureText(lines[i]);
          lw[i] = m.actualBoundingBoxRight / 2;
          if( m.actualBoundingBoxRight > xd )
            xd = m.actualBoundingBoxRight;
        }
        xd /= 2;
      }

      var xdl = 0;
      for (var i = 0; i < lines.length; ++i) {
        if( centered )
          xdl = xd - lw[i]
        ctx.fillText(lines[i], x + xdl, y);
        y += lineHeight;
      }
    }

    function strokeTextMultiLine(ctx, text, x, y, hratio, centered) {
      var lines = text.split("\n");
      var m = ctx.measureText(lines[0]);
      var lineHeight = m.actualBoundingBoxAscent * hratio;
      var xd = 0;
      var lw = new Array(lines.length);
      y += m.actualBoundingBoxAscent;

      if( centered )
      {
        for (var i = 0; i < lines.length; ++i) {
          m = ctx.measureText(lines[i]);
          lw[i] = m.actualBoundingBoxRight / 2;
          if( m.actualBoundingBoxRight > xd )
            xd = m.actualBoundingBoxRight;
        }
        xd /= 2;
      }

      var xdl = 0;
      for (var i = 0; i < lines.length; ++i) {
        if( centered )
          xdl = xd - lw[i]
        ctx.strokeText(lines[i], x + xdl, y);
        y += lineHeight;
      }
    }

    if( query['clear_cache'] )
    {
      // disable caching
      console.log( 'Disabling files cache' );
      // 1. in THREE.objLoader
      THREE.Cache.enabled = false;
      // console.log('cached files:', THREE.Cache.files);
      // 2. in .getJSON
      $(document).ready(function() {
        $.ajaxSetup({ cache: false });
      });
    }

    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

    var renderer = new THREE.WebGLRenderer();
    // renderer.sortObjects = false;
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

    // SOUND
    var mediaElement = document.getElementById( 'audio_player' );

    var light = new THREE.DirectionalLight( 0xffffff, 0.8 );
    light.position.z = 1;
    light.target.z = 0;
//     scene.add( light );  // moved later
    scene.add( camera );

    var light2 = new THREE.AmbientLight( 0xffffff, 0.3 );
    scene.add( light2 );

    var controls = new OrbitControls( scene, camera, renderer.domEmlement );
//     var controls = new OrbitControls( camera, renderer.domElement );

//     camera.position.x = -450;
    camera.position.x = -600;
    camera.position.y = 600;
    camera.position.z = 200;
    var q0 = new THREE.Quaternion( 1, 0, 1, 0 );
    q0.setFromAxisAngle( new THREE.Vector3( 0, 0, 1 ), Math.PI );
    camera.quaternion.multiply( q0 );
    q0.setFromAxisAngle( new THREE.Vector3( 1, 0, 0 ), Math.PI / 4 );
    camera.quaternion.multiply( q0 );

    controls.update();
    var compass = new THREE.Group();
    var wratio = window.innerWidth / window.innerHeight;
    compass.position.x = -20.;
    compass.position.x *= wratio;
    compass.position.y = -20.;
    compass.position.z = -30;
    compass.scale.copy( new THREE.Vector3( 0.2, 0.2, 0.2 ) );
    camera.add( compass );
//     compass.scale.x = 10.;
//     compass.scale.y = 10.;
//     compass.scale.z = 10.;
//     scene.add( compass );

    function read_compass( url, filenames )
    {
        var i = 0;
        var ext = '.obj';

        for( i=0; i<filenames.length; i++ )
        {
            var fname = url + '/' + filenames[i] + '.mtl';
            // console.log('read_compass:', fname);

            var mtl_loader = new MTLLoader();
            mtl_loader.load(
                // resource URL
                fname,
                // called when resource is loaded
                function ( materials )
                {
                    materials.preload();

                    var objLoader = new OBJLoader();
                    objLoader.setMaterials(materials);
                    var mlist = [];
                    for( var m in materials.materials )
                    {
                        mlist.push( m.substr( 0, m.length - 2 ) );
                        if( m == 'sphere_0' )
                        {
                            materials.materials[m].opacity = 0.5;
                            materials.materials[m].transparent = true;
                        }
                    }

                    var fname = url + '/' + mlist[0] + ext;
                    // console.log('subload:', fname);
                    objLoader.load( fname,
                        function (object)
                        {
                            object.traverse( function ( child )
                            {
//                                 if ( child instanceof THREE.Mesh )
//                                 {
//                                     child.material.side = THREE.DoubleSide;
//                                 }
                                if ( child instanceof THREE.LineSegments )
                                {
                                    child.material.lights = false;
                                }
                            } );

                            object.scale.set( -1., 1., 1. );

                            compass.add(object);
                            render();

                        },
                        // called when loading is in progresses
                        function ( xhr ) {

//                             console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

                        },
                        // called when loading has errors
                        function ( error ) {

                                console.log( 'An error happened:', url, error );

                        });


                },
                // called when loading is in progresses
                function ( xhr ) {

//                         console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

                },
                // called when loading has errors
                function ( error ) {
                        console.log( 'An error happened:', url, error );
                }
            );
        }
    }

    read_compass( 'compass', ['sphere', 'north', 'sew', 'up', 'down',
        'semi', 'belt', 'wbelt'] );

    // load all objects list (meshes, texts, sounds)
    // ajax seems not to use the fetch callback in the SW. We need to use
    // another method.

//     var map_objects;
//     var obj_res = $.ajax({
//       url: 'map_objects.json',
//       async: false,
//       dataType: 'json',
//       success: function( json )
//       {
//         map_objects = json;
//       }
//     })

    var map_objects = await fetch('map_objects.json').then((response) => response.json());

    // console.log( 'map_objects:', map_objects );
    var allow_private = false;
    var filenames = map_objects.meshes;
    var texts = map_objects.texts;
    var sounds = map_objects.sounds;
    if ( !sounds )
      sounds = [];
    var photos = map_objects.photos;
    if ( !photos )
      photos = [];
    var categories = map_objects.categories;
    var def_categories = map_objects.default_categories;
    var def_cat_num = [];
    var private_code = map_objects['code'];
    if( private_code == null )
      private_code = '776f707e19f39e6b830856a6cdf3aa605a5a283e'

    console.log('camera light:', map_objects.camera_light);
    if( map_objects.camera_light != "off" )
      scene.add( light );

    console.log("get travel_speed_projection:", map_objects.travel_speed_projection);
    if( map_objects.travel_speed_projection != null )
    {
      controls.travel_speed_projection = map_objects.travel_speed_projection;
      console.log('set in controls.');
    }
    else console.log('DONT set them.');

    if( sha1(query['code']) == private_code )
    {
      console.log('ALLOW PRIVATE MODE');
      allow_private = true;
    }
    if( allow_private )
    {
      reset_object_lists( allow_private );
    }
    else
      document.getElementById( 'private_code_block' ).style.display = 'none';

    var mb = document.getElementById( 'mesh_buttons' );
    var md2 = document.getElementById( 'categories_sep' );

    for( var i=0; i!=categories.length; i++ )
    {
      var item = document.createElement( 'input' );
      item.type = 'checkbox';
      item.class = 'mesh_checkbox';
      item.id = categories[i];
      mb.insertBefore(item, md2);
      item = document.createElement( 'label' );
      item.setAttribute('for', categories[i]);
      var text = document.createTextNode( categories[i] );
      item.appendChild( text );
      mb.insertBefore( item, md2 );
      item = document.createElement( 'br' );
      mb.insertBefore( item, md2 );
    }

    function createPartial(func /*, 0..n args */) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function() {
            var allArguments = args.concat(Array.prototype.slice.call(arguments));
            return func.apply(this, allArguments);
        };
    }

    for( i=0; i!=categories.length; i++ )
    {
        var btn = document.getElementById( categories[i] );
        btn.addEventListener( 'click', createPartial( category_clicked, i ) );
        btn.checked = false;
    }

    for (i=0; i != def_categories.length; ++i )
    {
      var category = categories.indexOf( def_categories[i] );
      document.getElementById( categories[category] ).checked = true;
      def_cat_num.push( category );
    }

    var meshes = {};

    var url = 'meshes_obj/';
    /* code:
        0: main_corridors
        1: unreachable
        2: text
        3: parcels
        4: oss_off
        5: tech
        6: legend
    */

    function reset_object_lists( allow_private )
    {
        filenames = map_objects.meshes;
        texts = map_objects.texts;
        sounds = map_objects.sounds;
        if ( !sounds )
            sounds = [];
        photos = map_objects.photos;
        if ( !photos )
            photos = [];

        if( allow_private )
        {
            filenames = filenames.concat( map_objects.meshes_private );
            texts = texts.concat( map_objects.texts_private );
            if( map_objects.sounds_private )
                sounds = sounds.concat( map_objects.sounds_private );
            if( map_objects.photos_private )
                photos = photos.concat( map_objects.photos_private );
        }
    }


    function load_meshes( category )
    {

        console.debug('load meshes category', category );
        if( meshes[category] == null )
            meshes[category] = {};

        var mesh_cat = meshes[category];
        var i = 0;

        for( i=0; i<filenames.length; i++ )
        {
            var cat = filenames[i][0];
            if( cat != category )
                continue; // wrong group

            if( filenames[i][1].endsWith('.gltf')
                || filenames[i][1].endsWith('.glb') )
            {
                var gltfname = url + filenames[i][1];

                if( mesh_cat[gltfname] == null )
                    mesh_cat[gltfname] = [0, null]; // not loaded

                if( mesh_cat[gltfname][0] == 2 )
                {
                    scene.add( mesh_cat[gltfname][1] ); // loaded: add it in scene
                    // console.log('display object', gltfname);
                }
                if( mesh_cat[gltfname][0] != 0 )
                    continue; // loaded or loading: don't do it again

                var loader = new GLTFLoader();
                var dracoLoader = new DRACOLoader();

                mesh_cat[gltfname] = [1, null]; // loading

                dracoLoader.setDecoderPath( 'three/examples/jsm/libs/draco/' );
                loader.setDRACOLoader( dracoLoader );

                function loadedFunction(url) {
                    return function (gltf) {
                        mesh_cat[url] = [2, gltf.scene]; // loaded
                        // console.log('loaded:', url);

                        gltf.scene.traverse( function ( child )
                        {
                            if ( child instanceof THREE.Mesh )
                            {
                                if( child.material.opacity < 1. )
                                {
                                    child.material.transparent = true;
                                    // force depth write to be correct.
                                    child.material.depthWrite = true;
                                }
                                else
                                {
                                    child.material.transparent = false;
                                }
                                child.material.side = THREE.DoubleSide;
                                // console.log('double sided:', child);
                            }
                            if ( child instanceof THREE.LineSegments )
                            {
                                child.material.lights = false;
                            }
                        })

                        scene.add( gltf.scene );
                        render();

                    }
                }

                loader.load( gltfname, loadedFunction(gltfname) );
            }
            else
            {

                var fname = url + filenames[i][1] + '.mtl';
                var mname = url + filenames[i][1] + '.obj';
                // console.debug('fname:', fname);

                if( mesh_cat[mname] == null )
                    mesh_cat[mname] = [0, null]; // not loaded

                if( mesh_cat[mname][0] == 2 )
                {
                    scene.add( mesh_cat[mname][1] ); // loaded: add it in scene
                    // console.log('display object', mname);
                }
                if( mesh_cat[mname][0] != 0 )
                    continue; // loaded or loading: don't do it again

                var mtl_loader = new MTLLoader();
                mesh_cat[mname] = [1, null]; // loading
                mtl_loader.load(
                    // resource URL
                    fname,
                    // called when resource is loaded
                    function ( materials )
                    {
                        materials.preload();

                        var objLoader = new OBJLoader();
                        objLoader.setMaterials(materials);
                        var mlist = [];
                        for( var m in materials.materials )
                        {
                          mlist.push( m.substr( 0, m.length - 2 ) );
                        }

                        var fname = url + mlist[0] + '.obj';
                        objLoader.load( fname,
                            function (object)
                            {
                                mesh_cat[fname] = [2, object]; // loaded
                                object.traverse( function ( child )
                                {
                                    if ( child instanceof THREE.Mesh )
                                    {
                                        child.material.side = THREE.DoubleSide;
                                    }
                                    if ( child instanceof THREE.LineSegments )
                                    {
                                        child.material.lights = false;
                                    }
                                } );

                                object.scale.set( -1., 1., 1. );

                                // console.log('display object', fname);
                                scene.add(object);
                                render();

                            },
                            // called when loading is in progress
                            function ( xhr ) {

    //                             console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

                            },
                            // called when loading has errors
                            function ( error ) {

                                    console.log( 'An error happened:', url,
                                                ':', error );

                            });


                    },
                    // called when loading is in progresses
                    function ( xhr ) {

    //                         console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

                    },
                    // called when loading has errors
                    function ( error ) {
                            console.log( 'An error happened:', url, ':', error );
                            delete mesh_cat[fname];
                    }
                );
            } // obj
        }

        function nextPow2( aSize ){
          return Math.pow( 2, Math.ceil( Math.log( aSize ) / Math.log( 2 ) ) );
        }

        if( category == 2 && texts ) // texts
        {
            var ti = 0;
            for( ti=0; ti<texts.length; ti++ )
            {

                var fname = url + texts[ti][1];

                if( mesh_cat[fname] == null )
                    mesh_cat[fname] = [0, null]; // not loaded

                if( mesh_cat[fname][0] == 2 )
                    scene.add( mesh_cat[fname][1] ); // loaded: add it in scene
                if( mesh_cat[fname][0] != 0 )
                    continue; // loaded or loading: don't do it again

//                 console.log('fname', ti, ':', fname);
                var text_json = $.getJSON(fname,
                    function(json)
                    {
                      var tobjs = json.objects;
                      var group = new THREE.Group();
                      var oi = 0;

                      for( oi in tobjs )
                      {
                        var debug = false;
                        var trobj = tobjs[oi];
                        var pos = trobj.properties.position;
                        // var bsize = trobj.properties.size;
                        var bsize = [0., 0.];
                        var bitmap = document.createElement('canvas');
                        var g = bitmap.getContext('2d');
                        var background = '#ffffff00';
                        var scale = null;
                        var tscale = null;
                        var xmin = 0;
                        var xmax = 0;
                        var ymin = 0;
                        var ymax = 0;
                        var anchor = null;
                        var decaly = 0;

                        if( trobj.properties.background != null )
                        {
                          var bgcol = trobj.properties.background;
                          bgcol[0] = Math.round( bgcol[0] * 255. );
                          bgcol[1] = Math.round( bgcol[1] * 255. );
                          bgcol[2] = Math.round( bgcol[2] * 255. );
                          bgcol[3] = Math.round( bgcol[3] * 255. );
                          background = '#'
                              + ('00' + bgcol[0].toString(16)).substr(-2)
                              + ('00' + bgcol[1].toString(16)).substr(-2)
                              + ('00' + bgcol[2].toString(16)).substr(-2)
                              + ('00' + bgcol[3].toString(16)).substr(-2);
                        }

                        var oti = 0;

                        // compute exact size
                        for( oti in trobj.objects )
                        {
                          var tobj = trobj.objects[oti];
                          var ltscale = tobj.properties.scale;
                          if( scale == null )
                          {
                            scale = tobj.properties.scale;
                            tscale = 4.;
                          }
                          var fsize = tobj.properties.font_size;
                          var ffamily = tobj.properties.font_family;
                          var tpos = tobj.properties.position;
                          var tanchor = tobj.properties['text-anchor'];
                          if( tanchor != null && anchor == null )
                            anchor = tanchor;

                          if( fsize == null || fsize == 0. )
                            fsize = 10;
                          if( ffamily == null )
                            ffamily = 'Arial';
                          var text = tobj.properties.text;
                          if( text != null )
                          {
                              fsize *= tscale * ltscale / scale;
                              g.font = fsize + 'pt ' + ffamily;

                              var w = 0;
                              var h = 0;
                              var lines = text.split('\n');
                              const hratio = 1.5;
                              var m;
                              var tpos2 = [tpos[0] * tscale / scale, tpos[1] * tscale / scale];
//                               if( lines[0] == 'AVENUE KLEBER' )
//                               {
//                                 debug = true;
//                                 console.log('text:', text);
//                                 console.log('fsize:', fsize);
//                               }
                              for( i=0; i!=lines.length; i++ )
                              {
                                m = g.measureText( lines[i] );
                                //w = Math.max( w, m.actualBoundingBoxRight );
                                w = m.actualBoundingBoxRight
                                    - m.actualBoundingBoxLeft;
                                h += m.actualBoundingBoxAscent;
                                if( i != 0 )
                                  h += m.actualBoundingBoxAscent * (hratio - 1.);
                                if( xmin > tpos2[0] - w/2 )
                                  xmin = tpos2[0] - w/2;
                                if( xmax < tpos2[0] + w/2 )
                                  xmax = tpos2[0] + w/2;
                                if( debug )
                                  console.log('text:', lines[i], ', m:', m);
                              }
                              h += m.actualBoundingBoxDescent;
                              if( ymin > tpos2[1] - h/2 )
                                ymin = tpos2[1] - h/2;
                              if( ymax < tpos2[1] + h/2 )
                                ymax = tpos2[1] + h/2;

                              if( oti == 0 && lines.length >= 2 )
                                decaly = lines.length;
                          }
                        }
                        bsize[0] = xmax - xmin;
                        bsize[1] = ymax - ymin;

                        // bitmap.width = nextPow2( bsize[0] + 5 );
                        // bitmap.height = nextPow2( bsize[1] + 5 );
                        bitmap.width = bsize[0] + 10;
                        bitmap.height = bsize[1] + 10;
                        if( debug )
                        {
                          console.log('bsize:', bsize);
                          console.log('bitmap:', bitmap);
                        }
                        g.fillStyle = background;
                        g.fillRect(0, 0, bsize[0] + 10, bsize[1] + 10);
                        if( bitmap.width > 2000 || bitmap.height > 1000 )
                        {
                          console.log('texture too large:', bsize);
                          console.log('text:', text);
                          g.font = trobj.objects[0].properties.font_size * 2 + 'pt ' + trobj.objects[0].properties.font_family;
                          m = g.measureText( lines[0] );
                          console.log('m:', m);
                          console.log('trobj:', trobj);

                          if( bitmap.width > 2000 )
                          {
                            tscale *= 2000 / bitmap.width;
                            bitmap.width = 2000;
                          }
                          if( bitmap.height > 1000 )
                          {
                            tscale *= 1000 / bitmap.width;
                            bitmap.height = 1000;
                          }

                        }

                        for( oti in trobj.objects )
                        {
                          var tobj = trobj.objects[oti];
                          var ltscale = tobj.properties.scale;
                          var fsize = tobj.properties.font_size;
                          var ffamily = tobj.properties.font_family;
                          var material = tobj.properties.material;
                          var tpos = tobj.properties.position;
                          var tpos2 = [tpos[0] * tscale / scale, tpos[1] * tscale / scale];
                          var centered = true;
                          if( tobj.properties['text-anchor'] != 'middle' )
                            centered = false;
                          var fillcol = 'white';
                          var strokecol = '#606060ff';
                          if( material != null )
                          {
                              var col = material.diffuse;
                              if( col != null )
                              {
  //                                 // make texts ligher
  //                                 col[0] = Math.round( (1. - (1. - col[0]) / 2.)
  //                                                      * 255. );
  //                                 col[1] = Math.round( (1. - (1. - col[1]) / 2.)
  //                                                      * 255. );
  //                                 col[2] = Math.round( (1. - (1. - col[2]) / 2.)
  //                                                      * 255. );
                                  var strokefac = 0.4;
                                  if( col[0] * col[0] + col[1] * col[1]
                                      + col[2] * col[2] < 0.25 )
                                      strokefac = 1.5;
                                  var scol = col.slice();
                                  scol[0] *= strokefac;
                                  scol[1] *= strokefac;
                                  scol[2] *= strokefac;
                                  if( scol[0] < 0.4 )
                                    scol[0] = 0.4;
                                  if( scol[1] < 0.4 )
                                    scol[1] = 0.4;
                                  if( scol[2] < 0.4 )
                                    scol[2] = 0.4;
                                  if( scol[0] > 1. )
                                    scol[0] = 1.;
                                  if( scol[1] > 1. )
                                    scol[1] = 1.;
                                  if( scol[2] > 1. )
                                    scol[2] = 1.;

                                  col[0] = Math.round( col[0] * 255. );
                                  col[1] = Math.round( col[1] * 255. );
                                  col[2] = Math.round( col[2] * 255. );
                                  col[3] = Math.round( col[3] * 255. );
                                  fillcol = '#'
                                      + ('00' + col[0].toString(16)).substr(-2)
                                      + ('00' + col[1].toString(16)).substr(-2)
                                      + ('00' + col[2].toString(16)).substr(-2)
                                      + ('00' + col[3].toString(16)).substr(-2);
                                  scol[0] = Math.round( scol[0] * 255. );
                                  scol[1] = Math.round( scol[1] * 255. );
                                  scol[2] = Math.round( scol[2] * 255. );
                                  scol[3] = Math.round( scol[3] * 255. );
                                  strokecol = '#'
                                      + ('00' + scol[0].toString(16)).substr(-2)
                                      + ('00' + scol[1].toString(16)).substr(-2)
                                      + ('00' + scol[2].toString(16)).substr(-2)
                                      + ('00' + scol[3].toString(16)).substr(-2);
                              }
                          }
                          if( fsize == null || fsize == 0. )
                          {
                              fsize = 10;
                          }
                          if( ffamily == null )
                          {
              //                 ffamily = 'LMSansUltraCond10';
                              ffamily = 'Arial';
                          }
                          if( scale == 0. )
                          {
                              scale = 1.;
                          }
                          var text = tobj.properties.text;
          //                 console.debug('text:', text);
                          if( text != null )
                          {

                              // text in sprite

                              // var bitmap = document.createElement('canvas');
                              // var g = bitmap.getContext('2d');
                              fsize *= tscale * ltscale / scale;
                              // tscale /= 2;  // ? why ?
                              g.font = fsize + 'pt ' + ffamily;

                              var w = 0;
                              var lines = text.split('\n');
                              var m = null;
                              for( i=0; i!=lines.length; i++ )
                              {
                                m = g.measureText( lines[i] );
                                w = Math.max( w, m.actualBoundingBoxRight
                                                 - m.actualBoundingBoxLeft );
                              }
                              var hratio = 1.5;
                              if( debug )
                                console.log('text2:', text, ', w:', w, ', font:', fsize, ', col:', fillcol, '/', strokecol);
                              g.fillStyle = fillcol;
                              strokeTextMultiLine( g, text, tpos2[0] + 5 - w / 2 - xmin, tpos2[1] + 5, hratio, centered );
                              g.strokeStyle = strokecol;
                              fillTextMultiLine( g, text, tpos2[0] + 5 - w / 2 - xmin, tpos2[1] + 5, hratio, centered );

                          }
                        }

                        // canvas contents will be used for a texture
                        var texture = new THREE.Texture(bitmap);
                        texture.needsUpdate = true;
                        var spritmat = new THREE.SpriteMaterial( { map: texture, color: 0xffffff } );
                        var sprite = new THREE.Sprite( spritmat );
                        // var scale = 0.1;
                        var sw = bitmap.width * scale / tscale;
                        var sh = bitmap.height * scale / tscale;
                        sprite.scale.set( sw, sh );
                        // the svg position is under the 1st line of text
                        var y_shift = 1.;
                        sprite.position.x = -pos[0];
                        if( anchor != 'middle' )
                          sprite.position.x -= sw / 2;
                        sprite.position.y = pos[1];
                        if( decaly != 0 )
                        {
                          var dy = sh / decaly * (decaly - 1);
                          sprite.position.y += dy;
                        }
                        sprite.position.z = pos[2];
//                         console.log('anchor', anchor, pos, sprite.position, ':', text);
                        sprite.center.set(0.5, 0.);
                        if( debug )
                          console.log('text sprite pos:', sprite.position);

                        // console.debug("lines:", lines.length, ", yshift:", y_shift);

                        group.add( sprite );
                      }

                      scene.add( group );
                      mesh_cat[this.url] = [2, group];
                      console.log('loaded:', this.url);
                    }
                ).fail( function ()
                {
                  console.debug("text object load failed:", this.url);
                  delete mesh_cat[fname];
                }
                );

            }

        }

        render();

    }

    var title = map_objects.title;
    if( title && title.length != 0 )
    {
      for( i=0; i<title.length; i++ )
        $('#title_' + i).text(title[i]);
      $('#main_title').text(title[0]);
    }


    for( i=0; i<def_cat_num.length; i++ )
    {
      load_meshes( def_cat_num[i] );
    }

    mouse = new THREE.Vector2( 0, 0 );
    rayCaster = new THREE.Raycaster();

    controls.addEventListener( 'change', render ); // use if there is no animation loop
    window.addEventListener( 'resize', onWindowResize, false );
    document.addEventListener( 'mousedown', on_press_scene );
//     document.addEventListener( 'mouseup', on_release_scene );
    document.addEventListener( 'click', on_release_scene );


    function render() {
        var dir = new THREE.Vector3( 0, 0, 0 );
        dir = camera.getWorldDirection( dir );
        light.position.x = -dir.x;
        light.position.y = -dir.y;
        light.position.z = -dir.z;
        compass.quaternion.copy( camera.quaternion );
        compass.quaternion.invert();
        renderer.render( scene, camera );
    }


    function onWindowResize()
    {

        set_font_sizes();

        var wratio = window.innerWidth / window.innerHeight;
        camera.aspect = wratio;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

        // move compass to keep its corner position
        compass.position.x = -20.;
        compass.position.x *= wratio;

        render();
    }

    function unload_meshes(category)
    {
        console.log('unload meshes category:', category);

        var mesh_cat = meshes[category];
        // console.log('meshes:', mesh_cat);
        if( mesh_cat == null )
          return;
        var fname = '';
        for( fname in mesh_cat )
        {
          var obj_def = mesh_cat[fname];
          if( obj_def[0] == 2 )
              scene.remove( obj_def[1] );
//           delete mesh_cat[fname];
//           delete obj_def[1];
        }

        render();
    }

    function on_press_scene( event )
    {
      // I'm actually interested on clicks, not on press events...
      // record press position
      switch( event.which )
      {
      case 1: // left mouse click
        mouse.x = event.clientX;
        mouse.y = event.clientY;
      }
    }

    function on_release_scene( event )
    {
      // I'm actually interested on clicks, when release happens just after
      // press. But I don't know how to get time so I just check that the
      // position hasn't shifted much... FIXME...

      event.preventDefault();

      switch( event.which )
      {
      case 1: // left mouse click
        if( ( event.clientX - mouse.x ) * ( event.clientX - mouse.x )
            + ( event.clientY - mouse.y ) * ( event.clientY - mouse.y ) < 20 )
        {
          // let's say it's a click now.
          mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
          mouse.y = - ( event.clientY / window.innerHeight )* 2 + 1;

          rayCaster.setFromCamera( mouse, camera );
          var intersects = rayCaster.intersectObjects( scene.children, true );

          if( intersects.length > 0 )
          {
            console.log( 'intersects:', intersects );
            console.log( 'point:', intersects[0].point );
            if( check_compass_click( intersects ) )
              north_up();
            else
            {
              check_sounds( intersects[0].point );
              check_photos( intersects[0].point );
            }
          }
        }
      }
    }


    function stop_sound()
    {
      // stop any playing sound
//       if( current_sound.isPlaying )
//       {
//         current_sound.stop();
//       }
      mediaElement.pause();
      // mediaElement.src = '';
    }


    function check_sounds( point )
    {
      if( ! sounds )
        return;

      var max_dist = 10;
      var min_dist = 11;
      var snd_filename = '';
      for( i=0; i<sounds.length; i++ )
      {
        var spos = sounds[i][0];
        // TODO: x is inverted, check why is it not in the mesh coords ?
        var x = -spos[0];
        var y = spos[1];
        var z = spos[2];
        max_dist = spos[4];
        var fname = sounds[i][1][0];
        // console.log( 'sound:', x, y, z, fname, ', radius:', max_dist );
        var snd_pos = new THREE.Vector3( x, y, z );
        var dist = point.distanceTo( snd_pos );
        // console.log( 'distance:', dist, ', min:', min_dist );
        if( i == 0 )
          min_dist = dist;
        if( dist <= min_dist && dist < max_dist )
        {
          min_dist = dist;
          snd_filename = fname;
        }
      }

      stop_sound();

      if( snd_filename != '' )
      {
        console.log('play:', snd_filename );

        mediaElement.pause();
        mediaElement.src = snd_filename;
        mediaElement.play();
        mediaElement.style.display = 'block';
      }
    }


    function check_photos( point )
    {
      if( ! photos )
        return;

      var max_dist = 10;
      var min_dist = 11;
      var photo_filenames = [];
      for( i=0; i<photos.length; i++ )
      {
        var spos = photos[i][0];

        // TODO: x is inverted, check why is it not in the mesh coords ?
        var x = -spos[0];
        var y = spos[1];
        var z = point.z;
        // var z = spos[2];
        max_dist = spos[4];
        var fnames = photos[i][1];
        // console.log( 'photo:', x, y, z, fnames, ', radius:', max_dist );
        var photo_pos = new THREE.Vector3( x, y, z );
        var dist = point.distanceTo( photo_pos );
        // console.log( 'distance:', dist );
        if( i == 0 )
          min_dist = dist;
        if( dist <= min_dist && dist < max_dist )
        {
          min_dist = dist;
          photo_filenames = fnames;
        }
      }

      if( photo_filenames.length != 0 )
      {
        console.log( 'display photos:', x, y, z, photo_filenames, ', radius:', min_dist );
        display_photos( photo_filenames );
      }

    }


    function display_photos( photo_filenames )
    {

//       var tab = window.open( '', '_blank' );
//       tab.focus();
//       var doc = tab.document;
      var new_html = '<style>body { background-color: black; }</style>';
      var has_video = 0;
      var photo_urls = [];

      for( i=0; i<photo_filenames.length; i++ )
      {
        var photo_filename = photo_filenames[i];
        var ext = photo_filename.lastIndexOf( '/' );
        var basename = photo_filename;
        var photo_url = photo_filename;
        if( ext >= 0 )
          basename = photo_filename.substring( ext + 1 );
        ext = basename.indexOf( '.' );
        if( ext < 0 && basename != '' )
          photo_url = photo_filename + '.jpg';
        var tag = 'img';
        if( ext >= 0 )
        {
          var fext = basename.substring( ext+1 );
          console.log('fext:', fext );
          if( fext == 'mp4' || fext == 'mpg' )
          {
            tag = 'video';
            has_video = 1;
          }
        }
        if( tag == 'video' )
        {
          new_html +=  '<a href="' + photo_url + '" target="_blank"><video controls src="' + photo_url + '" height="100%" width="auto"><source src="' + photo_url + '" /></video></a> ';
        }
        else
          new_html +=  '<a href="' + photo_url + '" target="_blank"><' + tag + ' src="' + photo_url + '" height="100%" width="auto" /></a> ';
        photo_urls.push( [photo_url, tag] );
      }

      open_media( photo_urls );
    }


    function check_compass_click( intersects )
    {
      for( i=0; i<intersects.length; i++ )
      {
        var name = intersects[i].object.name;
        if( name == "sphere_0" )
          return true;
      }
      return false;
    }


    function north_up()
    {
      console.log('set north up');
      console.log('current quaternion:', camera.quaternion);
      var quat = new THREE.Quaternion();
      var dir = new THREE.Vector3( 0, 0, 1 );
      // angle of current axis around x
      var cur_dir = new THREE.Vector2( camera.quaternion.x,
                                       camera.quaternion.y );
      cur_dir.normalize();
      var angle = Math.acos( cur_dir.x );
      console.log('angle:', angle);
      quat.setFromAxisAngle( dir, Math.PI - angle );

//       quat.setFromAxisAngle( dir, Math.PI / 2);
//       var angle = camera.quaternion.angleTo(quat);
//       console.log('angle:', angle);
//       quat.setFromAxisAngle( dir, Math.PI / 2 - angle );

      quat.multiply( camera.quaternion );
      camera.quaternion.set( quat.x, quat.y, quat.z, quat.w );

//       var dir = new THREE.Vector3( camera.quaternion.x, camera.quaternion.y, camera.quaternion.z );
//       dir.normalize();
//       console.log('axis:', dir);
//       camera.quaternion.setFromAxisAngle( dir, Math.PI);
      render();
    }

    function set_map_2d_mode()
    {
      console.log('set map mode');
      var dir = new THREE.Vector3( 0, 0, 1 );
      camera.quaternion.setFromAxisAngle( dir, Math.PI);
      render();
    }

        </script>

        <div class="help" id="help_block">

            <h2>ContrÃ´les souris:</h2>

            <div class="control_help">
                Bouton gauche + gauche / droite: rotation de l'orientation<br/>
                Bouton gauche + haut / bas: avance / recule (altitude constante)<br/>
                Ctrl + bouton gauche + gauche / droite: rotation de l'orientation<br/>
                Ctrl + bouton gauche + haut / bas: avance droit (altitude variable)<br/>
                Bouton milieu + gauche / droite: rotation de l'orientation<br/>
                Bouton milieu + haut / bas: changement d'inclinaison de la vue<br/>
                Bouton droit + gauche / droite: dÃ©placement en crabe<br/>
                Bouton droit + haut / bas: changement d'altitude<br/><br/>

                Shift: multiplie par 5 la vitesse de dÃ©placement<br/>
                Alt: divise par 10 la vitesse de dÃ©placement
            </div>

            <h2>ContrÃ´les tactiles:</h2>

            <div class="control_help">
                1 doigt gauche + gauche / droite: rotation de l'orientation<br/>
                1 doigt + haut / bas: avance / recule<br/>
                2 doigts + gauche / droite: dÃ©placement en crabe<br/>
                2 doigts + haut / bas: changement d'altitude<br/>
                2 doigts pincement ("Ã©chelle"): avance droit (altitude variable)<br/>
                3 doigts + gauche / droite: rotation de l'orientation<br/>
                3 doigts + haut / bas: changement d'inclinaison de la vue
            </div>

            <h2>ContrÃ´les clavier:</h2>

            <div class="control_help">
                Gauche, droite: rotation de l'orientation<br/>
                Haut, bas: avance / recule (altitude constante)<br/>
                Ctrl + gauche, droite: dÃ©placement en crabe<br/>
                Ctrl + haut / bas: avance droit (altitude variable)<br/>
                Shift + gauche, droite: rotation de l'orientation<br/>
                Shift + Haut, bas: changement d'inclinaison de la vue<br/>
            </div>

            <button id="close_help" class="mesh_button">OK</button>
        </div>

<!--        <div id="debug_win">
        </div>-->

        <script>

            function close_help_clicked( event )
            {
                event.stopPropagation();
                document.getElementById( 'help_block' ).style.display = 'none';
            }

            function open_help_clicked( event )
            {
                event.stopPropagation();
                if( document.getElementById( 'help_block' ).style.display == 'block' )
                    document.getElementById( 'help_block' ).style.display = 'none';
                else
                    document.getElementById( 'help_block' ).style.display = 'block';
            }


            function toggle_show_buttons()
            {
              console.log('toggle_show_buttons');
              if( document.getElementById( 'mesh_buttons' ).style.display == 'none' )
              {
                console.log('show');
                document.getElementById( 'mesh_buttons' ).style.display = 'block';
                document.getElementById( 'show_buttons' ).innerHTML = '&#x25BC;';
              }
              else
              {
                console.log('hide');
                document.getElementById( 'mesh_buttons' ).style.display = 'none';
                document.getElementById( 'show_buttons' ).innerHTML = '&#x25B6';
              }
            }

            document.getElementById( 'help' ).addEventListener( 'click', open_help_clicked );
            document.getElementById( 'close_help' ).addEventListener( 'click', close_help_clicked );
            document.getElementById( 'show_buttons' ).addEventListener( 'click', toggle_show_buttons );

        </script>

        <fieldset class="player" id="media_player">
            <legend>Vues:</legend>

            <div class="media" id="media_frame" style="display: block; position: absolute; top: 0%; left: 0%; width: 100%, height: 100%; max-width: 100%; max-height: 100%">
            </div>

            <button id="close_media" class="media_button" style="display: inline; position: absolute; top: 1%; left: 2%; z-index: 20; border-radius: 12%">&#10006;</button>
            <button class="media_button"></button>
            <button id="enlarge_media" class="media_button" style="display: inline; position: absolute; top: 1%; right: 2%; z-index: 20; border-radius: 12%">&#x26F6;</button>
            <button id="media_prev" class="media_button" style="display: inline; position: absolute; top: 45%; left: 2%; z-index: 20; border-radius: 50%">&lt;</button>
            <button id="media_text" class="media_button2" style="display: inline; position: absolute; bottom: 2%; left: 30%; width: 40%; text-align: center; border-radius: 20%">BB</button>
            <button id="media_next" class="media_button" style="display: inline; position: absolute; top: 45%; right: 2%; z-index: 20; border-radius: 50%">&gt;</button>
        </fieldset>

        <script>

            function close_media_clicked( event )
            {
              if( event != null )
                  event.stopPropagation();
              document.getElementById( 'media_player' ).style.display = 'none';
              var media = document.getElementById( 'photo_frame' );
              if( media )
                media.parentNode.removeChild( media );
            }

            function open_media( photo_files )
            {
              close_media_clicked();

              document.getElementById( 'media_player' ).style.display = 'block';
              var media = document.getElementById( 'media_frame' );
              media.large = false;
              media.photos = photo_files;
              display_photo( 0 );
            }

            function display_photo( num )
            {
              var photo = document.getElementById( 'photo_frame' );
              var parent = document.getElementById( 'media_frame' );
              var photo_files = parent.photos;
              var player = document.getElementById( 'media_player' );
              if( photo )
                parent.removeChild( photo );
              var tag = photo_files[num][1];
              photo = document.createElement( tag );
              parent.num = num;
              parent.style.width = "100%";
              parent.style.height = "100%";
              photo.id = 'photo_frame';
              photo.style.textAlign = 'center';
              photo.style.align = 'center';
              photo.style.display = 'block';
              photo.style.margin = '0px auto 0px';
              photo.style.maxWidth = '100%';
              photo.style.maxHeight = '100%';

              if( num == 0 )
                document.getElementById( 'media_prev' ).style.display = 'none';
              else
                document.getElementById( 'media_prev' ).style.display = 'inline';
              if( num == photo_files.length - 1 )
                document.getElementById( 'media_next' ).style.display = 'none';
              else
                document.getElementById( 'media_next' ).style.display = 'inline';

              if( parent.large )
              {
                player.style.maxWidth = '94%';
                player.style.maxHeight = '94%';
                player.style.width = '94%';
                player.style.height = '94%';
              }
              else
              {
                player.style.maxWidth = '30%';
                player.style.maxHeight = '40%';
                player.style.width = '30%';
                player.style.height = '40%';
              }

              photo.src = photo_files[num][0];
              if( tag == 'video' )
              {
                // stop_sound();  // avoid sound + video at the same time
                // curiously the above line now causes
                // "stop_sound is not defined" error. Why ?
                var mediaElement = document.getElementById( 'audio_player' );
                mediaElement.pause();

                photo.controls = 'true';
                photo.style.maxHeight = '90%';
                var src = document.createElement( 'source' );
                src.src = photo_files[num][0];
              }
              else
              {
                photo.src = photo_files[num][0];
                photo.onclick = display_large_photo;
              }
              parent.appendChild( photo );

              document.getElementById( 'media_text' ).innerHTML = (num + 1) + ' / ' + photo_files.length;
            }

            function prev_media_clicked()
            {
              event.stopPropagation();
              var media = document.getElementById( 'media_frame' );
              var photo_files = media.photos;
              var num = media.num;
              if( num > 0 )
                display_photo( num - 1 );
            }


            function next_media_clicked(event)
            {
              event.stopPropagation();
              var media = document.getElementById( 'media_frame' );
              var photo_files = media.photos;
              var num = media.num;
              if( num < photo_files.length - 1 )
                display_photo( num + 1 );
            }

            function enlarge_media_clicked(event)
            {
              event.stopPropagation();
              var media = document.getElementById( 'media_frame' );
              var large = media.large;
              large = !large;
              media.large = large;
              var photo = document.getElementById( 'photo_frame' );
              var player = document.getElementById( 'media_player' )
              if( large )
              {
                player.style.maxWidth = '94%';
                player.style.maxHeight = '94%';
                player.style.width = '94%';
                player.style.height = '94%';
              }
              else
              {
                player.style.maxWidth = '30%';
                player.style.maxHeight = '40%';
                player.style.width = '30%';
                player.style.height = '40%';
              }
            }


            function display_large_photo()
            {
              var media = document.getElementById( 'media_frame' );
              var photo_files = media.photos;
              var num = media.num;
              window.open( photo_files[num][0] ).focus();
            }


            document.getElementById( 'close_media' ).addEventListener( 'click', close_media_clicked, {capture: true} );
            document.getElementById( 'enlarge_media' ).addEventListener( 'click', enlarge_media_clicked,  {capture: true});
            document.getElementById( 'media_prev' ).addEventListener( 'click', prev_media_clicked, {capture: true} );
            document.getElementById( 'media_next' ).addEventListener( 'click', next_media_clicked, {capture: true} );

        </script>

    </body>
</html>
