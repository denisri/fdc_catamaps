<!DOCTYPE html>
<html>
    <head>
        <meta charset=utf-8>
        <title>GRS 14 2021</title>
        <style>
            body {
                margin: 0;
                background: #000;
                text-align: center;
                color: #fff;
                overflow-y: hidden;
                touch-action: none;
/*                 font-size: 20px; */
            }
            canvas {
              width: 100%;
              height: 100%;
              z-index: 2;
              top: 300px;
            }
            .right_col {
                align-content: right;
                align-items: right;
                position: absolute;
                font-size: 18px;
            }
            .button_bar {
                width: 100%;
                align-content: right;
                position: absolute;
                top: 0%;
                right: 1%;
                background: #60606080;
                font-size: 18px;
                display: block;
            }
            fieldset {
                border: 1px solid #888;
                align-content: left;
                text-align: left;
                width: 25%;
/*                 display: inline-block; */
                float: right;
                right: 0%;
                z-index: 10;
            }
            .mesh_button {
                background: #50505080;
                border: 1px;
                border-color: #80808080;
                color: #d0d0d0;
                width: 100%;
                z-index: 10;
            }
            .mesh_checkbox {
                background: #50505080;
                border: 1px;
                border-color: #80808080;
                color: #d0d0d0;
                z-index: 10;
            }
            .top_row {
                position: absolute;
                top: 0%;
                left: 0%;
                width: 100%;
                text-align: center;
                color: #a0a0a0;
                z-index: 10;
            }
            .bottom_row {
                position: absolute;
/*                 top: 90%; */
                bottom: 0%;
                width: 100%;
                text-align: center;
                color: #a0a0a0;
                z-index: 0;
            }
            .help {
                display: none;
                z-index: 3;
                position: absolute;
                top: 20%;
                left: 20%;
            }
            .control_help {
                text-align: left;
            }
            .player {
                display: none;
                z-index: 30;
                position: absolute;
                top: 2%;
                left: 2%;
                width: 30%;
                height: 40%;
                background: #60606080;
            }
            .media_frame {
                width: 100%;
                height: 100%;
                display: block;
                z-index: 10;
            }
            .photo_frame {
                margin: 0px auto 0px;
                width: 100%;
                height: 100%;
                display: block;
            }
            .media_button {
                background: #80808080;
                border: 1px;
                border-color: #80808080;
                color: #d0d0d0;
                width: 30px;
                z-index: 10;
                font-size: 18px;
            }
            .media_button2 {
                background: #50505080;
                border: 1px;
                border-color: #80808080;
                color: #d0d0d0;
                width: 40%;
                z-index: 10;
                font-size: 18px;
            }
            #debug_win {
                position: absolute;
                top: 20%;
                left: 20%;
                display: block;
            }
        </style>
    </head>
    <body>


      <div class="top_row">
        <h1 id="title_0">GRAND RÉSEAU SUD</h1>
        <h3 id="title_1">LE FOND DU CREW 2022</h3>
        <h3 id="title_2"></h3>
      </div>

      <div class="button_bar" id="button_bar">
        <fieldset id="mesh_fields" class="right_col">
          <legend>Charger/voir:</legend>
          <div id="mesh_buttons">
            <button id="all" class="mesh_button">Tous</button><br/>
            <br id="categories_sep" />
            <input type="checkbox" id="map_mode" class="mesh_checkbox">
              <label>Mode 2D</label></input><br/>
            <button id="help" class="mesh_button">Aide</button>
          </div>
        </fieldset>
        <button id="show_buttons" class="media_button" style="position: absolute; top: 10px; right: 1%; z-index: 20">&#x25BC;</button>
      </div>

      <div style="border: 0px; bottom: 0%; left: 0%; width: 100%; height: auto; display: block; position: absolute; margin: auto;">
        <audio controls id="audio_player" style="display: none; margin-left: auto; margin-right: auto; bottom: 2%; z-index: 20;"/>
      </div>

        <script>

    function sha1 (str) {
      //  discuss at: https://locutus.io/php/sha1/
      // original by: Webtoolkit.info (https://www.webtoolkit.info/)
      // improved by: Michael White (https://getsprink.com)
      // improved by: Kevin van Zonneveld (https://kvz.io)
      //    input by: Brett Zamir (https://brett-zamir.me)
      //      note 1: Keep in mind that in accordance with PHP, the whole string is buffered and then
      //      note 1: hashed. If available, we'd recommend using Node's native crypto modules directly
      //      note 1: in a steaming fashion for faster and more efficient hashing
      //   example 1: sha1('Kevin van Zonneveld')
      //   returns 1: '54916d2e62f65b3afa6e192e6a601cdbe5cb5897'
      let hash
      try {
        const crypto = require('crypto')
        const sha1sum = crypto.createHash('sha1')
        sha1sum.update(str)
        hash = sha1sum.digest('hex')
      } catch (e) {
        hash = undefined
      }
      if (hash !== undefined) {
        return hash
      }
      const _rotLeft = function (n, s) {
        const t4 = (n << s) | (n >>> (32 - s))
        return t4
      }
      const _cvtHex = function (val) {
        let str = ''
        let i
        let v
        for (i = 7; i >= 0; i--) {
          v = (val >>> (i * 4)) & 0x0f
          str += v.toString(16)
        }
        return str
      }
      let blockstart
      let i, j
      const W = new Array(80)
      let H0 = 0x67452301
      let H1 = 0xEFCDAB89
      let H2 = 0x98BADCFE
      let H3 = 0x10325476
      let H4 = 0xC3D2E1F0
      let A, B, C, D, E
      let temp
      // utf8_encode
      str = unescape(encodeURIComponent(str))
      const strLen = str.length
      const wordArray = []
      for (i = 0; i < strLen - 3; i += 4) {
        j = str.charCodeAt(i) << 24 |
          str.charCodeAt(i + 1) << 16 |
          str.charCodeAt(i + 2) << 8 |
          str.charCodeAt(i + 3)
        wordArray.push(j)
      }
      switch (strLen % 4) {
        case 0:
          i = 0x080000000
          break
        case 1:
          i = str.charCodeAt(strLen - 1) << 24 | 0x0800000
          break
        case 2:
          i = str.charCodeAt(strLen - 2) << 24 | str.charCodeAt(strLen - 1) << 16 | 0x08000
          break
        case 3:
          i = str.charCodeAt(strLen - 3) << 24 |
            str.charCodeAt(strLen - 2) << 16 |
            str.charCodeAt(strLen - 1) <<
          8 | 0x80
          break
      }
      wordArray.push(i)
      while ((wordArray.length % 16) !== 14) {
        wordArray.push(0)
      }
      wordArray.push(strLen >>> 29)
      wordArray.push((strLen << 3) & 0x0ffffffff)
      for (blockstart = 0; blockstart < wordArray.length; blockstart += 16) {
        for (i = 0; i < 16; i++) {
          W[i] = wordArray[blockstart + i]
        }
        for (i = 16; i <= 79; i++) {
          W[i] = _rotLeft(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1)
        }
        A = H0
        B = H1
        C = H2
        D = H3
        E = H4
        for (i = 0; i <= 19; i++) {
          temp = (_rotLeft(A, 5) + ((B & C) | (~B & D)) + E + W[i] + 0x5A827999) & 0x0ffffffff
          E = D
          D = C
          C = _rotLeft(B, 30)
          B = A
          A = temp
        }
        for (i = 20; i <= 39; i++) {
          temp = (_rotLeft(A, 5) + (B ^ C ^ D) + E + W[i] + 0x6ED9EBA1) & 0x0ffffffff
          E = D
          D = C
          C = _rotLeft(B, 30)
          B = A
          A = temp
        }
        for (i = 40; i <= 59; i++) {
          temp = (_rotLeft(A, 5) + ((B & C) | (B & D) | (C & D)) + E + W[i] + 0x8F1BBCDC) & 0x0ffffffff
          E = D
          D = C
          C = _rotLeft(B, 30)
          B = A
          A = temp
        }
        for (i = 60; i <= 79; i++) {
          temp = (_rotLeft(A, 5) + (B ^ C ^ D) + E + W[i] + 0xCA62C1D6) & 0x0ffffffff
          E = D
          D = C
          C = _rotLeft(B, 30)
          B = A
          A = temp
        }
        H0 = (H0 + A) & 0x0ffffffff
        H1 = (H1 + B) & 0x0ffffffff
        H2 = (H2 + C) & 0x0ffffffff
        H3 = (H3 + D) & 0x0ffffffff
        H4 = (H4 + E) & 0x0ffffffff
      }
      temp = _cvtHex(H0) + _cvtHex(H1) + _cvtHex(H2) + _cvtHex(H3) + _cvtHex(H4)
      return temp.toLowerCase()
    }



    function all_clicked(event)
    {
        console.debug('ALL clicked.');

        var i = 0;

        for( i=0; i!=categories.length; i++ )
            document.getElementById( categories[i] ).checked = true;
        for( i=0; i!=categories.length; i++ )
            category_clicked( i, document.getElementById( categories[i] ) );
    }

    function category_clicked(category, event)
    {
        var display = this.checked;
        if( display == undefined )
            display = event.checked;
        console.debug(categories[category], display);
        if( display )
            load_meshes( category );
        else
            unload_meshes( category );
    }

    function map_mode_clicked(event)
    {
        var display = this.checked;
        if( display == undefined )
            display = event.checked;
        console.debug('map_mode clicked.', display);
        controls.mode_2d = display;
        if( display )
            set_map_2d_mode();
    }

    function set_font_sizes()
    {
        if(window.innerWidth < window.innerHeight )
        {
            document.getElementById( 'mesh_fields' ).style['font-size']
                = '4.0vw';
            document.getElementById( 'all' ).style['font-size']
                = '4.0vw';
            document.getElementById( 'help' ).style['font-size']
                = '4.0vw';
        }
        else if( window.innerWidth > 700 )
        {
//             var font_size = Math.round( window.innerWidth * 0.01 );
            document.getElementById( 'mesh_fields' ).style['font-size']
                = '2.0vw';
//                 = font_size + 'px';
            document.getElementById( 'all' ).style['font-size']
                = '2.0vw';
//                 = font_size + 'px';
            document.getElementById( 'help' ).style['font-size']
                = '2.0vw';
//                 = font_size + 'px';
        }
    }

    function query_string( url )
    {
      var q_url = url.split('?');
      if( q_url.length < 2 )
        return {};
      q_url = q_url[1];
      var qArr = q_url.split('&')
          ,qObj = {}
          ,i =-1;
      while(++i<qArr.length) {
              qfrag = qArr[i].split('=');
              qObj[qfrag[0]] = qfrag[1];
      }
      return qObj;
    }


    var query = query_string( document.URL );

    set_font_sizes();

    var mouse;
    var rayCaster;
    var current_sound;

    document.getElementById( 'all' ).addEventListener( 'click', all_clicked );
    document.getElementById( 'map_mode' ).addEventListener( 'click', map_mode_clicked );

        </script>



        <script src="three.js"></script>
        <script src="OBJLoader.js"></script>
        <script src="MTLLoader.js"></script>
        <script src="OrbitControls2.js"></script>
        <script src="jquery.js"></script>

        <script>

    // from https://stackoverflow.com/questions/5026961/html5-canvas-ctx-filltext-wont-do-line-breaks/21574562#21574562
    function fillTextMultiLine(ctx, text, x, y, hratio) {
      var lineHeight = ctx.measureText("M").width * hratio;
      var lines = text.split("\n");
      for (var i = 0; i < lines.length; ++i) {
        ctx.fillText(lines[i], x, y);
        y += lineHeight;
      }
    }

    function strokeTextMultiLine(ctx, text, x, y, hratio) {
      var lineHeight = ctx.measureText("M").width * hratio;
      var lines = text.split("\n");
      for (var i = 0; i < lines.length; ++i) {
        ctx.strokeText(lines[i], x, y);
        y += lineHeight;
      }
    }

    if( query['clear_cache'] )
    {
      // disable caching
      console.log( 'Disabling files cache' );
      // 1. in THREE.objLoader
      THREE.Cache.enabled = false;
      // console.log('cached files:', THREE.Cache.files);
      // 2. in .getJSON
      $(document).ready(function() {
        $.ajaxSetup({ cache: false });
      });
    }

    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

    var renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

    // SOUND
    var mediaElement = document.getElementById( 'audio_player' );

    var light = new THREE.DirectionalLight( 0xffffff, 0.8 );
    light.position.z = 1;
    light.target.z = 0;
    scene.add( light );
    scene.add( camera );

    var light2 = new THREE.AmbientLight( 0xffffff, 0.3 );
    scene.add( light2 );

    var controls = new THREE.OrbitControls( scene, camera );

//     camera.position.x = -450;
    camera.position.x = -600;
    camera.position.y = 600;
    camera.position.z = 200;
    var q0 = new THREE.Quaternion( 1, 0, 1, 0 );
    q0.setFromAxisAngle( new THREE.Vector3( 0, 0, 1 ), Math.PI );
    camera.quaternion.multiply( q0 );
    q0.setFromAxisAngle( new THREE.Vector3( 1, 0, 0 ), Math.PI / 4 );
    camera.quaternion.multiply( q0 );

    controls.update();
    var compass = new THREE.Group();
    var wratio = window.innerWidth / window.innerHeight;
    compass.position.x = -20.;
    compass.position.x *= wratio;
    compass.position.y = -20.;
    compass.position.z = -30;
    compass.scale.copy( new THREE.Vector3( 0.2, 0.2, 0.2 ) );
    camera.add( compass );
//     compass.scale.x = 10.;
//     compass.scale.y = 10.;
//     compass.scale.z = 10.;
//     scene.add( compass );

    function read_compass( url, filenames )
    {
        var i = 0;
        var ext = '.obj';

        for( i=0; i<filenames.length; i++ )
        {
            var fname = url + '/' + filenames[i] + '.mtl';
            // console.log('read_compass:', fname);

            var mtl_loader = new THREE.MTLLoader();
            mtl_loader.load(
                // resource URL
                fname,
                // called when resource is loaded
                function ( materials )
                {
                    materials.preload();

                    var objLoader = new THREE.OBJLoader();
                    objLoader.setMaterials(materials);
                    var mlist = [];
                    for( m in materials.materials )
                    {
                        mlist.push( m.substr( 0, m.length - 2 ) );
                        if( m == 'sphere_0' )
                        {
                            materials.materials[m].opacity = 0.5;
                            materials.materials[m].transparent = true;
                        }
                    }

                    var fname = url + '/' + mlist[0] + ext;
                    // console.log('subload:', fname);
                    objLoader.load( fname,
                        function (object)
                        {
                            object.traverse( function ( child )
                            {
//                                 if ( child instanceof THREE.Mesh )
//                                 {
//                                     child.material.side = THREE.DoubleSide;
//                                 }
                                if ( child instanceof THREE.LineSegments )
                                {
                                    child.material.lights = false;
                                }
                            } );

                            object.scale.set( -1., 1., 1. );

                            compass.add(object);
                            render();

                        },
                        // called when loading is in progresses
                        function ( xhr ) {

//                             console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

                        },
                        // called when loading has errors
                        function ( error ) {

                                console.log( 'An error happened:', this.url, error );

                        });


                },
                // called when loading is in progresses
                function ( xhr ) {

//                         console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

                },
                // called when loading has errors
                function ( error ) {
                        console.log( 'An error happened:', this.url, error );
                }
            );
        }
    }

    read_compass( 'compass', ['sphere', 'north', 'sew', 'up', 'down',
        'semi', 'belt', 'wbelt'] );

    // load all objects list (meshes, texts, sounds)
    var map_objects;
    var obj_res = $.ajax({
      url: 'map_objects.json',
      async: false,
      dataType: 'json',
      success: function( json )
      {
        map_objects = json;
      }
    })
    // console.log( 'map_objects:', map_objects );
    var allow_private = false;
    var filenames = map_objects.meshes;
    var texts = map_objects.texts;
    var sounds = map_objects.sounds;
    if ( !sounds )
      sounds = [];
    var photos = map_objects.photos;
    if ( !photos )
      photos = [];
    var categories = map_objects.categories;
    var def_categories = map_objects.default_categories;
    var def_cat_num = [];
    var private_code = map_objects['code'];
    if( private_code == null )
      private_code = '776f707e19f39e6b830856a6cdf3aa605a5a283e'

    if( sha1(query['code']) == private_code )
    {
      console.log('ALLOW PRIVATE MODE');
      allow_private = true;
    }
    if( allow_private )
    {
      filenames = filenames.concat( map_objects.meshes_private );
      texts = texts.concat( map_objects.texts_private );
      if( map_objects.sounds_private )
        sounds = sounds.concat( map_objects.sounds_private );
      if( map_objects.photos_private )
        photos = photos.concat( map_objects.photos_private );
    }

    var mb = document.getElementById( 'mesh_buttons' );
    var md2 = document.getElementById( 'categories_sep' );

    for( i=0; i!=categories.length; i++ )
    {
      var item = document.createElement( 'input' );
      item.type = 'checkbox';
      item.class = 'mesh_checkbox';
      item.id = categories[i];
      mb.insertBefore(item, md2);
      item = document.createElement( 'label' );
      var text = document.createTextNode( categories[i] );
      item.appendChild( text );
      mb.insertBefore( item, md2 );
      item = document.createElement( 'br' );
      mb.insertBefore( item, md2 );
    }

    function createPartial(func /*, 0..n args */) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function() {
            var allArguments = args.concat(Array.prototype.slice.call(arguments));
            return func.apply(this, allArguments);
        };
    }

    for( i=0; i!=categories.length; i++ )
    {
        var btn = document.getElementById( categories[i] );
        btn.addEventListener( 'click', createPartial( category_clicked, i ) );
        btn.checked = false;
    }

    for (i=0; i != def_categories.length; ++i )
    {
      var category = categories.indexOf( def_categories[i] );
      document.getElementById( categories[category] ).checked = true;
      def_cat_num.push( category );
    }

    var meshes = {};

    var url = 'meshes_obj/';
    /* code:
        0: main_corridors
        1: unreachable
        2: text
        3: parcels
        4: oss_off
        5: tech
        6: legend
    */

    function load_meshes( category )
    {

        console.debug('load meshes category', category );
        if( meshes[category] == null )
            meshes[category] = {};

        var mesh_cat = meshes[category];
        var i = 0;

        for( i=0; i<filenames.length; i++ )
        {
            var cat = filenames[i][0];
            if( cat != category )
                continue; // wrong group

            var fname = url + filenames[i][1] + '.mtl';
            var mname = url + filenames[i][1] + '.obj';
            // console.debug('fname:', fname);

            if( mesh_cat[mname] == null )
                mesh_cat[mname] = [0, null]; // not loaded

            if( mesh_cat[mname][0] == 2 )
            {
                scene.add( mesh_cat[mname][1] ); // loaded: add it in scene
                // console.log('display object', mname);
            }
            if( mesh_cat[mname][0] != 0 )
                continue; // loaded or loading: don't do it again

            var mtl_loader = new THREE.MTLLoader();
            mesh_cat[mname] = [1, null]; // loading
            mtl_loader.load(
                // resource URL
                fname,
                // called when resource is loaded
                function ( materials )
                {
                    materials.preload();

                    var objLoader = new THREE.OBJLoader();
                    objLoader.setMaterials(materials);
                    var mlist = [];
                    for( m in materials.materials )
                    {
                      mlist.push( m.substr( 0, m.length - 2 ) );
                    }

                    var fname = url + mlist[0] + '.obj';
                    objLoader.load( fname,
                        function (object)
                        {
                            mesh_cat[fname] = [2, object]; // loaded
                            object.traverse( function ( child )
                            {
                                if ( child instanceof THREE.Mesh )
                                {
                                    child.material.side = THREE.DoubleSide;
                                }
                                if ( child instanceof THREE.LineSegments )
                                {
                                    child.material.lights = false;
                                }
                            } );

                            object.scale.set( -1., 1., 1. );

                            // console.log('display object', fname);
                            scene.add(object);
                            render();

                        },
                        // called when loading is in progress
                        function ( xhr ) {

//                             console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

                        },
                        // called when loading has errors
                        function ( error ) {

                                console.log( 'An error happened:', this.url,
                                             ':', error );

                        });


                },
                // called when loading is in progresses
                function ( xhr ) {

//                         console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

                },
                // called when loading has errors
                function ( error ) {
                        console.log( 'An error happened:', this.url );
                        delete mesh_cat[fname];
                }
            );
        }

        function nextPow2( aSize ){
          return Math.pow( 2, Math.ceil( Math.log( aSize ) / Math.log( 2 ) ) );
        }

        if( category == 2 ) // texts
        {
            for( i=0; i<texts.length; i++ )
            {

                var fname = url + texts[i][1];

                if( mesh_cat[fname] == null )
                    mesh_cat[fname] = [0, null]; // not loaded

                if( mesh_cat[fname][0] == 2 )
                    scene.add( mesh_cat[fname][1] ); // loaded: add it in scene
                if( mesh_cat[fname][0] != 0 )
                    continue; // loaded or loading: don't do it again

//                 console.log('fname', i, ':', fname);
                text_json = $.getJSON(fname,
                    function(json)
                    {
                      var tobjs = json.objects;
                      var group = new THREE.Group();

                      for( i in tobjs )
                      {
                        var trobj = tobjs[i];
                        var pos = trobj.properties.position;
                        var tobj = trobj.objects[0];
                        var scale = tobj.properties.scale;
                        var fsize = tobj.properties.font_size;
                        var ffamily = tobj.properties.font_family;
                        var material = tobj.properties.material;
                        var fillcol = 'white';
                        if( material != null )
                        {
                            var col = material.diffuse;
                            if( col != null )
                            {
//                                 // make texts ligher
//                                 col[0] = Math.round( (1. - (1. - col[0]) / 2.)
//                                                      * 255. );
//                                 col[1] = Math.round( (1. - (1. - col[1]) / 2.)
//                                                      * 255. );
//                                 col[2] = Math.round( (1. - (1. - col[2]) / 2.)
//                                                      * 255. );
                                col[0] = Math.round( col[0] * 255. );
                                col[1] = Math.round( col[1] * 255. );
                                col[2] = Math.round( col[2] * 255. );
                                col[3] = Math.round( col[3] * 255. );
                                fillcol = '#'
                                    + ('00' + col[0].toString(16)).substr(-2)
                                    + ('00' + col[1].toString(16)).substr(-2)
                                    + ('00' + col[2].toString(16)).substr(-2)
                                    + ('00' + col[3].toString(16)).substr(-2);
                            }
                        }
                        if( fsize == null || fsize == 0. )
                        {
                            fsize = 10;
                        }
                        if( ffamily == null )
                        {
            //                 ffamily = 'LMSansUltraCond10';
                            ffamily = 'Arial';
                        }
                        if( scale == 0. )
                        {
                            scale = 1.;
                        }
                        var text = tobj.properties.text;
        //                 console.debug('text:', text);

                        // text in sprite

                        var bitmap = document.createElement('canvas');
                        var g = bitmap.getContext('2d');
                        fsize *= 4;
                        if( fsize < 20 )
                        {
                            scale *= fsize / 20.;
                            fsize = 20;
                        }
                        g.font = 'Bold ' + fsize + 'px ' + ffamily;

        //                 var w = g.measureText(text).width;
                        var w = 0;
                        var lines = text.split('\n');
                        for( i=0; i!=lines.length; i++ )
                        {
                          w = Math.max( w, g.measureText( lines[i] ).width );
                        }
                        if( w < 16 )
                            w = 16;
                        var hratio = 1.6;
                        var h = g.measureText('M').width * hratio * lines.length;
                        bitmap.width = nextPow2( w + 5 );
                        bitmap.height = nextPow2( h + 5 );
        //                 console.debug('text size:', bitmap.width, bitmap.height );
                        g.font = 'Bold ' + fsize + 'px ' + ffamily;
                        g.fillStyle = fillcol;
        //                 g.fillText(text, 0, fsize);
                        fillTextMultiLine( g, text, 0, fsize, hratio );
                        g.strokeStyle = 'black';
        //                 g.strokeText(text, 0, fsize);
                        strokeTextMultiLine( g, text, 0, fsize, hratio );

                        // canvas contents will be used for a texture
                        var texture = new THREE.Texture(bitmap);
                        texture.needsUpdate = true;
                        var spritmat = new THREE.SpriteMaterial( { map: texture, color: 0xffffff } );
                        var sprite = new THREE.Sprite( spritmat );
                        sprite.scale.set( w * 0.1, h * 0.1 );
            //             sprite.scale.x = sprite.scale.x * scale;
            //             sprite.scale.y = sprite.scale.y * scale;
            //             sprite.scale.z = sprite.scale.z * scale;
//                         sprite.position.x = -pos[0]; // + bitmap.width / 2 * sprite.scale.x;
                        // the svg position is under the 1st line of text
                        var y_shift = 1.; // / lines.length;
                        sprite.position.x = -pos[0] - sprite.scale.x / 4;
                        sprite.position.y = pos[1] + sprite.scale.y * y_shift * 0.25;
                        sprite.position.z = pos[2] + sprite.scale.y * y_shift * 0.5;

                        // console.debug("lines:", lines.length, ", yshift:", y_shift);

                        group.add( sprite );
                      }

                      scene.add( group );
                      mesh_cat[this.url] = [2, group];
                      console.log('loaded:', this.url);
                    }
                ).fail( function ()
                {
                  console.debug("text object load failed:", this.url);
                  delete mesh_cat[fname];
                }
                );

            }

        }

        render();

    }

    var title = map_objects.title;
    if( title && title.length != 0 )
    {
      for( i=0; i<title.length; i++ )
        $('#title_' + i).text(title[i]);
    }


    for( i=0; i<def_cat_num.length; i++ )
    {
      load_meshes( def_cat_num[i] );
    }

    mouse = new THREE.Vector2( 0, 0 );
    rayCaster = new THREE.Raycaster();

    controls.addEventListener( 'change', render ); // use if there is no animation loop
    window.addEventListener( 'resize', onWindowResize, false );
    document.addEventListener( 'mousedown', on_press_scene );
    document.addEventListener( 'mouseup', on_release_scene );


    function render() {
        var dir = new THREE.Vector3( 0, 0, 0 );
        dir = camera.getWorldDirection( dir );
        light.position.x = -dir.x;
        light.position.y = -dir.y;
        light.position.z = -dir.z;
        compass.quaternion.copy( camera.quaternion );
        compass.quaternion.inverse();
        renderer.render( scene, camera );
    }


    function onWindowResize()
    {

        set_font_sizes();

        var wratio = window.innerWidth / window.innerHeight;
        camera.aspect = wratio;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

        // move compass to keep its corner position
        compass.position.x = -20.;
        compass.position.x *= wratio;

        render();
    }

    function unload_meshes(category)
    {
        console.log('unload meshes category:', category);

        mesh_cat = meshes[category];
        if( mesh_cat == null )
          return;
        var fname = '';
        for( fname in mesh_cat )
        {
          var obj_def = mesh_cat[fname];
          if( obj_def[0] == 2 )
              scene.remove( obj_def[1] );
//           delete mesh_cat[fname];
//           delete obj_def[1];
        }

        render();
    }

    function on_press_scene( event )
    {
      // I'm actually interested on clicks, not on press events...
      // record press position
      switch( event.which )
      {
      case 1: // left mouse click
        mouse.x = event.clientX;
        mouse.y = event.clientY;
      }
    }

    function on_release_scene( event )
    {
      // I'm actually interested on clicks, when release happens just after
      // press. But I don't know how to get time so I just check that the
      // position hasn't shifted much... FIXME...

      event.preventDefault();

      switch( event.which )
      {
      case 1: // left mouse click
        if( ( event.clientX - mouse.x ) * ( event.clientX - mouse.x )
            + ( event.clientY - mouse.y ) * ( event.clientY - mouse.y ) < 20 )
        {
          // let's say it's a click now.
          mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
          mouse.y = - ( event.clientY / window.innerHeight )* 2 + 1;

          rayCaster.setFromCamera( mouse, camera );
          var intersects = rayCaster.intersectObjects( scene.children, true );

          if( intersects.length > 0 )
          {
            console.log( 'intersects:', intersects );
            console.log( 'point:', intersects[0].point );
            if( check_compass_click( intersects ) )
              north_up();
            else
            {
              check_sounds( intersects[0].point );
              check_photos( intersects[0].point );
            }
          }
        }
      }
    }


    function stop_sound()
    {
      // stop any playing sound
//       if( current_sound.isPlaying )
//       {
//         current_sound.stop();
//       }
      mediaElement.pause();
      // mediaElement.src = '';
    }


    function check_sounds( point )
    {
      if( ! sounds )
        return;

      var max_dist = 10;
      var min_dist = 11;
      var snd_filename = '';
      for( i=0; i<sounds.length; i++ )
      {
        var spos = sounds[i][0];
        // TODO: x is inverted, check why is it not in the mesh coords ?
        var x = -spos[0];
        var y = spos[1];
        var z = spos[2];
        max_dist = spos[3];
        var fname = sounds[i][1][0];
        // console.log( 'sound:', x, y, z, fname, ', radius:', max_dist );
        var snd_pos = new THREE.Vector3( x, y, z );
        var dist = point.distanceTo( snd_pos );
        // console.log( 'distance:', dist );
        if( i == 0 )
          min_dist = dist;
        if( dist <= min_dist && dist < max_dist )
        {
          min_dist = dist;
          snd_filename = fname;
        }
      }

      stop_sound();

      if( snd_filename != '' )
      {
        console.log('play:', snd_filename );

        mediaElement.pause();
        mediaElement.src = snd_filename;
        mediaElement.play();
        mediaElement.style.display = 'block';
      }
    }


    function check_photos( point )
    {
      if( ! photos )
        return;

      var max_dist = 10;
      var min_dist = 11;
      var photo_filenames = [];
      for( i=0; i<photos.length; i++ )
      {
        var spos = photos[i][0];

        // TODO: x is inverted, check why is it not in the mesh coords ?
        var x = -spos[0];
        var y = spos[1];
        var z = point.z;
        // var z = spos[2];
        max_dist = spos[3];
        var fnames = photos[i][1];
        // console.log( 'photo:', x, y, z, fnames, ', radius:', max_dist );
        var photo_pos = new THREE.Vector3( x, y, z );
        var dist = point.distanceTo( photo_pos );
        // console.log( 'distance:', dist );
        if( i == 0 )
          min_dist = dist;
        if( dist <= min_dist && dist < max_dist )
        {
          min_dist = dist;
          photo_filenames = fnames;
        }
      }

      if( photo_filenames.length != 0 )
      {
        console.log( 'display photos:', x, y, z, photo_filenames, ', radius:', min_dist );
        display_photos( photo_filenames );
      }

    }


    function display_photos( photo_filenames )
    {

//       var tab = window.open( '', '_blank' );
//       tab.focus();
//       var doc = tab.document;
      var new_html = '<style>body { background-color: black; }</style>';
      var has_video = 0;
      var photo_urls = [];

      for( i=0; i<photo_filenames.length; i++ )
      {
        var photo_filename = photo_filenames[i];
        var ext = photo_filename.lastIndexOf( '/' );
        var basename = photo_filename;
        var photo_url = photo_filename;
        if( ext >= 0 )
          basename = photo_filename.substring( ext + 1 );
        ext = basename.indexOf( '.' );
        if( ext < 0 && basename != '' )
          photo_url = photo_filename + '.jpg';
        var tag = 'img';
        if( ext >= 0 )
        {
          var fext = basename.substring( ext+1 );
          console.log('fext:', fext );
          if( fext == 'mp4' || fext == 'mpg' )
          {
            tag = 'video';
            has_video = 1;
          }
        }
        if( tag == 'video' )
        {
          new_html +=  '<a href="' + photo_url + '" target="_blank"><video controls src="' + photo_url + '" height="100%" width="auto"><source src="' + photo_url + '" /></video></a> ';
        }
        else
          new_html +=  '<a href="' + photo_url + '" target="_blank"><' + tag + ' src="' + photo_url + '" height="100%" width="auto" /></a> ';
        photo_urls.push( [photo_url, tag] );
      }

      open_media( photo_urls );
    }


    function check_compass_click( intersects )
    {
      for( i=0; i<intersects.length; i++ )
      {
        var name = intersects[i].object.name;
        if( name == "sphere_0" )
          return true;
      }
      return false;
    }


    function north_up()
    {
      console.log('set north up');
      console.log('current quaternion:', camera.quaternion);
      var quat = new THREE.Quaternion();
      var dir = new THREE.Vector3( 0, 0, 1 );
      // angle of current axis around x
      var cur_dir = new THREE.Vector2( camera.quaternion.x,
                                       camera.quaternion.y );
      cur_dir.normalize();
      var angle = Math.acos( cur_dir.x );
      console.log('angle:', angle);
      quat.setFromAxisAngle( dir, Math.PI - angle );

//       quat.setFromAxisAngle( dir, Math.PI / 2);
//       var angle = camera.quaternion.angleTo(quat);
//       console.log('angle:', angle);
//       quat.setFromAxisAngle( dir, Math.PI / 2 - angle );

      quat.multiply( camera.quaternion );
      camera.quaternion.set( quat.x, quat.y, quat.z, quat.w );

//       var dir = new THREE.Vector3( camera.quaternion.x, camera.quaternion.y, camera.quaternion.z );
//       dir.normalize();
//       console.log('axis:', dir);
//       camera.quaternion.setFromAxisAngle( dir, Math.PI);
      render();
    }

    function set_map_2d_mode()
    {
      console.log('set map mode');
      var dir = new THREE.Vector3( 0, 0, 1 );
      camera.quaternion.setFromAxisAngle( dir, Math.PI);
      render();
    }

        </script>

        <div class="help" id="help_block">

            <h2>Contrôles souris:</h2>

            <div class="control_help">
                Bouton gauche + gauche / droite: rotation de l'orientation<br/>
                Bouton gauche + haut / bas: avance / recule (altitude constante)<br/>
                Ctrl + bouton gauche + gauche / droite: rotation de l'orientation<br/>
                Ctrl + bouton gauche + haut / bas: avance droit (altitude variable)<br/>
                Bouton milieu + gauche / droite: rotation de l'orientation<br/>
                Bouton milieu + haut / bas: changement d'inclinaison de la vue<br/>
                Bouton droit + gauche / droite: déplacement en crabe<br/>
                Bouton droit + haut / bas: changement d'altitude
            </div>

            <h2>Contrôles tactiles:</h2>

            <div class="control_help">
                1 doigt gauche + gauche / droite: rotation de l'orientation<br/>
                1 doigt + haut / bas: avance / recule<br/>
                2 doigts + gauche / droite: déplacement en crabe<br/>
                2 doigts + haut / bas: changement d'altitude<br/>
                2 doigts pincement ("échelle"): avance droit (altitude variable)<br/>
                3 doigts + gauche / droite: rotation de l'orientation<br/>
                3 doigts + haut / bas: changement d'inclinaison de la vue
            </div>

            <h2>Contrôles clavier:</h2>

            <div class="control_help">
                Gauche, droite: rotation de l'orientation<br/>
                Haut, bas: avance / recule (altitude constante)<br/>
                Ctrl + gauche, droite: déplacement en crabe<br/>
                Ctrl + haut / bas: avance droit (altitude variable)<br/>
                Shift + gauche, droite: rotation de l'orientation<br/>
                Shift + Haut, bas: changement d'inclinaison de la vue<br/>
            </div>

            <button id="close_help" class="mesh_button">OK</button>
        </div>

<!--        <div id="debug_win">
        </div>-->

        <script>

            function close_help_clicked()
            {
                document.getElementById( 'help_block' ).style.display = 'none';
            }

            function open_help_clicked()
            {
                if( document.getElementById( 'help_block' ).style.display == 'block' )
                    document.getElementById( 'help_block' ).style.display = 'none';
                else
                    document.getElementById( 'help_block' ).style.display = 'block';
            }


            function toggle_show_buttons()
            {
              console.log('toggle_show_buttons');
              if( document.getElementById( 'mesh_buttons' ).style.display == 'none' )
              {
                console.log('show');
                document.getElementById( 'mesh_buttons' ).style.display = 'block';
                document.getElementById( 'show_buttons' ).innerHTML = '&#x25BC;';
              }
              else
              {
                console.log('hide');
                document.getElementById( 'mesh_buttons' ).style.display = 'none';
                document.getElementById( 'show_buttons' ).innerHTML = '&#x25B6';
              }
            }

            document.getElementById( 'help' ).addEventListener( 'click', open_help_clicked );
            document.getElementById( 'close_help' ).addEventListener( 'click', close_help_clicked );
            document.getElementById( 'show_buttons' ).addEventListener( 'click', toggle_show_buttons );

        </script>

        <fieldset class="player" id="media_player">
            <legend>Vues:</legend>

            <div class="media" id="media_frame" style="display: block; position: absolute; top: 0%; left: 0%; width: 100%, height: 100%; max-width: 100%; max-height: 100%">
            </div>

            <button id="close_media" class="media_button" style="display: inline; position: absolute; top: 1%; left: 2%; z-index: 20; border-radius: 12%">&#10006;</button>
            <button class="media_button"></button>
            <button id="enlarge_media" class="media_button" style="display: inline; position: absolute; top: 1%; right: 2%; z-index: 20; border-radius: 12%">&#x26F6;</button>
            <button id="media_prev" class="media_button" style="display: inline; position: absolute; top: 45%; left: 2%; z-index: 20; border-radius: 50%">&lt;</button>
            <button id="media_text" class="media_button2" style="display: inline; position: absolute; bottom: 2%; left: 30%; width: 40%; text-align: center; border-radius: 20%">BB</button>
            <button id="media_next" class="media_button" style="display: inline; position: absolute; top: 45%; right: 2%; z-index: 20; border-radius: 50%">&gt;</button>
        </fieldset>

        <script>

            function close_media_clicked( event )
            {
              document.getElementById( 'media_player' ).style.display = 'none';
              var media = document.getElementById( 'photo_frame' );
              if( media )
                media.parentNode.removeChild( media );
            }

            function open_media( photo_files )
            {
              close_media_clicked();

              document.getElementById( 'media_player' ).style.display = 'block';
              var media = document.getElementById( 'media_frame' );
              media.large = false;
              media.photos = photo_files;
              display_photo( 0 );
            }

            function display_photo( num )
            {
              var photo = document.getElementById( 'photo_frame' );
              var parent = document.getElementById( 'media_frame' );
              var photo_files = parent.photos;
              var player = document.getElementById( 'media_player' )
              if( photo )
                parent.removeChild( photo );
              var tag = photo_files[num][1];
              photo = document.createElement( tag );
              parent.num = num;
              parent.style.width = "100%";
              parent.style.height = "100%";
              photo.id = 'photo_frame';
              photo.style.textAlign = 'center';
              photo.style.align = 'center';
              photo.style.display = 'block';
              photo.style.margin = '0px auto 0px';
              photo.style.maxWidth = '100%';
              photo.style.maxHeight = '100%';

              if( num == 0 )
                document.getElementById( 'media_prev' ).style.display = 'none';
              else
                document.getElementById( 'media_prev' ).style.display = 'inline';
              if( num == photo_files.length - 1 )
                document.getElementById( 'media_next' ).style.display = 'none';
              else
                document.getElementById( 'media_next' ).style.display = 'inline';

              if( parent.large )
              {
                player.style.maxWidth = '94%';
                player.style.maxHeight = '94%';
                player.style.width = '94%';
                player.style.height = '94%';
              }
              else
              {
                player.style.maxWidth = '30%';
                player.style.maxHeight = '40%';
                player.style.width = '30%';
                player.style.height = '40%';
              }

              photo.src = photo_files[num][0];
              if( tag == 'video' )
              {
                stop_sound();  // avoid sound + video at the same time

                photo.controls = 'true';
                photo.style.maxHeight = '90%';
                var src = document.createElement( 'source' );
                src.src = photo_files[num][0];
              }
              else
              {
                photo.src = photo_files[num][0];
                photo.onclick = display_large_photo;
              }
              parent.appendChild( photo );

              document.getElementById( 'media_text' ).innerHTML = (num + 1) + ' / ' + photo_files.length;
            }

            function prev_media_clicked()
            {
              var media = document.getElementById( 'media_frame' );
              var photo_files = media.photos;
              var num = media.num;
              if( num > 0 )
                display_photo( num - 1 );
            }


            function next_media_clicked()
            {
              var media = document.getElementById( 'media_frame' );
              var photo_files = media.photos;
              var num = media.num;
              if( num < photo_files.length - 1 )
                display_photo( num + 1 );
            }

            function enlarge_media_clicked()
            {
              var media = document.getElementById( 'media_frame' );
              var large = media.large;
              large = !large;
              media.large = large;
              var photo = document.getElementById( 'photo_frame' );
              var player = document.getElementById( 'media_player' )
              if( large )
              {
                player.style.maxWidth = '94%';
                player.style.maxHeight = '94%';
                player.style.width = '94%';
                player.style.height = '94%';
              }
              else
              {
                player.style.maxWidth = '30%';
                player.style.maxHeight = '40%';
                player.style.width = '30%';
                player.style.height = '40%';
              }
            }


            function display_large_photo()
            {
              var media = document.getElementById( 'media_frame' );
              var photo_files = media.photos;
              var num = media.num;
              window.open( photo_files[num][0] ).focus();
            }


            document.getElementById( 'close_media' ).addEventListener( 'click', close_media_clicked, {capture: true} );
            document.getElementById( 'enlarge_media' ).addEventListener( 'click', enlarge_media_clicked,  {capture: true});
            document.getElementById( 'media_prev' ).addEventListener( 'click', prev_media_clicked, {capture: true} );
            document.getElementById( 'media_next' ).addEventListener( 'click', next_media_clicked, {capture: true} );

        </script>

    </body>
</html>
